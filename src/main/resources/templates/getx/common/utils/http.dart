/// Generated by Flutter GetX Starter on ${.now?string("yyyy-MM-dd HH:mm")}
import 'dart:async';
import 'dart:io';

import 'package:cookie_jar/cookie_jar.dart';
import 'package:dio/adapter.dart';
import 'package:dio/dio.dart';
import 'package:fluttertoast/fluttertoast.dart';
import '../app_config.dart';
import './http/cookie_manager.dart';
import './logger.dart';

class Http {
  static Dio _dio;
  static const int SEND_TIMEOUT = 10000;
  static const int RECEIVE_TIMEOUT = 3000;
  static const int CONNECT_TIMEOUT = 10000;

  static Dio _create({bool useProxy = false}) {
    if (_dio == null) {
      // 全局属性：请求前缀、连接超时时间、响应超时时间
      BaseOptions options = new BaseOptions(
        baseUrl: Constant.HTTP_HOST,
        sendTimeout: SEND_TIMEOUT,
        connectTimeout: CONNECT_TIMEOUT,
        receiveTimeout: RECEIVE_TIMEOUT,
      );
      _dio = new Dio(options);
      //自定义Cookie
      _dio?.interceptors.add(PrivateCookieManager(CookieJar()));
      //开启请求日志
      _dio?.interceptors.add(LogInterceptor(
        responseBody: true,
        requestBody: true,
        logPrint: (obj) => Logger.debug(obj),
      ));
      //设置代理抓包
      if (useProxy) {
        (_dio?.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) {
          //这一段是解决https抓包的问题
          client.badCertificateCallback = (X509Certificate cert, String host, int port) {
            return true;
          };
          //设置花瓶的代理ip
          client.findProxy = (uri) {
            return "PROXY 10.2.2.108:8899";
          };
        };
      }
    }
    return _dio;
  }

  static _parseData(Map<String, dynamic> data) {
    int code = int.tryParse(data["code"].toString()) ?? 0;
    if (data.isNotEmpty && code == 200) {
      Map<String, dynamic> obj = data['data'];
      int rtnflag = int.tryParse(obj["rtnflag"].toString()) ?? 0;
      if (rtnflag == -201) {
        Fluttertoast.showToast(msg: obj["msg"], gravity: ToastGravity.CENTER);
      }
      return obj;
    } else {
      Fluttertoast.showToast(msg: "网络异常:$code", gravity: ToastGravity.CENTER);
    }
  }

  static Future<Map<String, dynamic>> get(
      String url, {
        Map<String, dynamic> params,
        Map<String, dynamic> headers,
      }) async {
    Response response = await _create().get(url, queryParameters: params, options: Options(headers: headers));
    return _parseData(response.data);
  }

  static Future<Map<String, dynamic>> post(
      String url, {
        Map<String, dynamic> params,
        Map<String, dynamic> headers,
      }) async {
    Response response = await _create().post(url, data: params, options: Options(headers: headers));
    return _parseData(response.data);
  }
}